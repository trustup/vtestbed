def rtu_code(sensors_input, actuators_input, ip_model, name, path_temp_script):

    length_holding_reg = 100
    with open(r'{}/code_{}.py'.format(path_temp_script,name), 'w') as f:
        f.write('import time\n')
        f.write("import modbus_tk\nimport modbus_tk.defines as cst\nimport modbus_tk.modbus_tcp as modbus_tcp\nimport struct\n\n")

        f.write("sensors_address = {}\n".format(sensors_input))
        f.write("actuators_address = {}\n".format(actuators_input))

        f.write('def unpack_float(fl):\n')
        f.write("    a = struct.unpack('>HH', struct.pack('>f',fl))\n")
        f.write("    return(a)\n\n")

        f.write('actuators = []\n')
        f.write('def write_act_local():\n')
        f.write('    actuators = [0] * len(actuators_address)\n')
        f.write('    r_a = len(sensors_address) * 2\n')
        f.write('    for idx, x in enumerate(actuators_address):\n')
        f.write("        a = master.execute(1, cst.READ_HOLDING_REGISTERS, x, 2, data_format='>f')\n")
        f.write('        actuators[idx] = a[0]\n')
        f.write('        fl = unpack_float(a[0])\n')
        f.write('        slave.set_values("a", r_a, fl)\n')
        f.write('        r_a = r_a + 2\n')
        f.write('    return actuators\n\n')

        f.write('def get_act_local():\n')
        f.write('    r_a = len(sensors_address) * 2\n')
        f.write('    cr = [0] * len(actuators_address)\n')
        f.write('    for idx, x in enumerate(actuators_address):\n')
        f.write("        ab = master_local.execute(1, cst.READ_HOLDING_REGISTERS, r_a, 2, data_format='>f')\n")
        f.write('        cr[idx] = ab[0]\n')
        f.write('        r_a = r_a + 2\n')
        f.write('    return(cr)\n\n')

        f.write('def act_control():\n')
        f.write('    if len(actuators_address) != 0:\n')
        f.write('        current = get_act_local()\n')
        f.write('        for idx, x in enumerate(actuators):\n')
        f.write('            if current[idx] != x:\n')
        f.write('                actuators[idx] = current[idx]\n')
        f.write("                master.execute(1, cst.WRITE_MULTIPLE_REGISTERS, starting_address=actuators_address[idx],output_value=[current[idx]], data_format='>f')\n")
        f.write('            time.sleep(0.5)\n\n')

        f.write('sensors=[]\n')
        f.write('sensors = [0] * len(sensors_address)\n')
        f.write('def write_sens_local():\n')
        f.write('    r_s = 0\n')
        f.write('    for idx, x in enumerate(sensors_address):\n')
        f.write("        b = master.execute(1, cst.READ_HOLDING_REGISTERS, x, 2, data_format='>f')\n")
        f.write('        sensors[idx] = b[0]\n')
        f.write('        fl2 = unpack_float(b[0])\n')
        f.write('        slave.set_values("a", r_s, fl2)\n')
        f.write('        r_s = r_s + 2\n')
        f.write('time.sleep(0.5)\n\n')

        f.write('if __name__ == "__main__":\n\n')
        f.write('    server = modbus_tcp.TcpServer()\n')
        f.write('    server.start()\n')
        f.write('    slave1 = server.add_slave(1)\n')
        f.write('    slave1.add_block("a", cst.HOLDING_REGISTERS, 0, {})  # address 0\n'.format(length_holding_reg))
        f.write('    slave = server.get_slave(1)\n')
        f.write('    master = modbus_tcp.TcpMaster(host="{}", port=502) #IP MODEL\n'.format(ip_model))
        f.write('    master_local = modbus_tcp.TcpMaster(host="localhost", port=502) #IP LOCAL\n\n')
        f.write('    if len(actuators_address) != 0:\n')
        f.write('        actuators = write_act_local()\n\n')
        f.write('    while True:\n')
        f.write('        write_sens_local()\n')
        f.write('        act_control()\n')

    f.close()
